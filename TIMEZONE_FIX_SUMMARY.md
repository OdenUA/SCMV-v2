# Исправление проблемы с парсингом времени от сервера

## Проблема
При обработке данных от сервера возникала проблема с некорректным парсингом времени, что приводило к сдвигу времени на 2 часа при генерации SQL запросов для удаления данных.

### Корневая причина
**Сервер присылает время в локальном часовом поясе** в формате ISO: `"2025-10-30T05:27:00"` (без суффикса 'Z').

Функция `parseTrackDate` в `device_track.js` **ошибочно добавляла 'Z'** к этой строке:
```javascript
// БЫЛО (неправильно):
if(/^(\d{4})-(\d{2})-(\d{2})T\d{2}:\d{2}:\d{2}$/.test(str)) return new Date(str+'Z');
```

Это приводило к следующей цепочке преобразований:
1. Сервер: `"2025-10-30T05:27:00"` (локальное время, например UTC+2)
2. parseTrackDate добавляет 'Z': `"2025-10-30T05:27:00Z"`
3. Браузер интерпретирует 'Z' как UTC и преобразует: `05:27:00 UTC → 07:27:00 Local (UTC+2)`
4. SQL генерируется с неправильным временем: `07:27:00` вместо `05:27:00`

## Решение

### Исправление в `device_track.js` (строка 50-60)

**БЫЛО:**
```javascript
function parseTrackDate(str){
  if(!str) return new Date(NaN);
  if(typeof str !== 'string') return new Date(str);
  if(/^(\d{2})\.(\d{2})\.(\d{2})\s\d{2}:\d{2}:\d{2}$/.test(str)) return new Date('20'+str.replace(/(\d{2})\.(\d{2})\.(\d{2})\s/, '$3-$2-$1T'));
  if(/^(\d{2})\.(\d{2})\.(\d{4})\s\d{2}:\d{2}:\d{2}$/.test(str)) return new Date(str.replace(/(\d{2})\.(\d{2})\.(\d{4})\s/, '$3-$2-$1T'));
  if(/^(\d{4})-(\d{2})-(\d{2})T\d{2}:\d{2}:\d{2}$/.test(str)) return new Date(str+'Z'); // ❌ ОШИБКА
  if(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(str)) return new Date(str);
  return new Date(str);
}
```

**СТАЛО:**
```javascript
function parseTrackDate(str){
  if(!str) return new Date(NaN);
  if(typeof str !== 'string') return new Date(str);
  if(/^(\d{2})\.(\d{2})\.(\d{2})\s\d{2}:\d{2}:\d{2}$/.test(str)) return new Date('20'+str.replace(/(\d{2})\.(\d{2})\.(\d{2})\s/, '$3-$2-$1T'));
  if(/^(\d{2})\.(\d{2})\.(\d{4})\s\d{2}:\d{2}:\d{2}$/.test(str)) return new Date(str.replace(/(\d{2})\.(\d{2})\.(\d{4})\s/, '$3-$2-$1T'));
  // Server sends local time, not UTC - parse as local time without 'Z' suffix
  if(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})$/.test(str)) {
    var m = str.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})$/);
    return new Date(Number(m[1]), Number(m[2])-1, Number(m[3]), Number(m[4]), Number(m[5]), Number(m[6]));
  }
  if(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(str)) return new Date(str);
  return new Date(str);
}
```

**Ключевые изменения:**
- Убрано добавление 'Z' к строке времени
- Добавлен явный парсинг как локального времени через конструктор `new Date(year, month, day, hour, min, sec)`
- Комментарий объясняет, что сервер присылает локальное время

## Результат

После исправления:
- ✅ Время парсится корректно без дополнительного преобразования часовых поясов
- ✅ SQL генерируется с правильным временем
- ✅ Удаление данных происходит с корректным временным диапазоном
- ✅ `recalcstartstop` вызывается для правильных дат

### Пример

**До исправления:**
```sql
-- Время от сервера: "2025-10-30T05:27:00" (локальное)
-- После парсинга с 'Z': 07:27:00 (неправильно, сдвиг +2 часа)
DELETE FROM snsrmain WHERE deviceid='1632' AND wdate >= '2025-10-30 07:27:00' AND wdate <= '...';
-- ❌ Удаляются не те данные!
```

**После исправления:**
```sql
-- Время от сервера: "2025-10-30T05:27:00" (локальное)
-- После парсинга без 'Z': 05:27:00 (правильно)
DELETE FROM snsrmain WHERE deviceid='1632' AND wdate >= '2025-10-30 05:27:00' AND wdate <= '...';
-- ✅ Удаляются правильные данные!
```

## Важное замечание

**Сервер присылает время в локальном часовом поясе**, поэтому:
- ❌ НЕ нужно добавлять 'Z' при парсинге
- ❌ НЕ нужно использовать UTC методы (`getUTCHours()`, `getUTCDate()`)
- ✅ Нужно использовать локальные методы (`getHours()`, `getDate()`)
- ✅ Нужно парсить строки как локальное время

Все функции генерации SQL корректно используют локальное время:
- `buildTrackCutSql` в `route.js`
- `generateSqlFromIntervals` в `device_track.js`
- `generateAnomalySql` в `utils.js`

